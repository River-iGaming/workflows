name: Merge to Higher Branches
on:
  workflow_call:
    inputs:
      version-file:
        description: File containing the app version
        required: false
        type: string
        default: "package.json"
      target-branch-pattern:
        description: Regex pattern for target branches
        required: false
        type: string
        default: "[0-9]+\\.x"
      target-branches:
        description: Explicit list of target branches
        required: false
        type: string
    secrets:
      github-token:
        required: true

jobs:
  get-branches:
    name: Merge to Higher Branches
    runs-on: ubuntu-latest
    outputs:
      all-branches: ${{ steps.branch-info.outputs.all-branches }}
      current-branch: ${{ steps.branch-info.outputs.current-branch }}
      branch-skip: ${{ steps.branch-info.outputs.branch-skip }}
      commit-skip: ${{ steps.check-last-commit.outputs.commit-skip }}
    steps:
      - name: Checkout full history
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Skip if last commit was an merge higher
        id: check-last-commit
        run: |
          msg=$(git log -1 --pretty=%B HEAD)
          echo "Last commit message: $msg"

          if [[ "$msg" == chore\(*\):\ changes\ merged\ and\ with\ version\ bump\ to* ]]; then
            echo "commit-skip=true" >> $GITHUB_OUTPUT
          else
            echo "commit-skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Get branch info
        id: branch-info
        if: ${{ steps.check-last-commit.outputs.commit-skip == 'false' }}
        run: |
          git config user.email "deploy-bot@riverigaming.com"
          git config user.name "rig-autobot"

          echo "::group::concurrency group"
          echo "::notice concurrency-group=${{ github.workflow }}"
          echo "::notice concurrency-group-branch=${{ github.ref }}"
          echo "::notice concurrency-group-run-id=${{ github.run_id }}"
          echo "::notice concurrency-group-head-ref=${{ github.head_ref }}"
          echo "::notice concurrency-group-triggering_actor=${{ github.triggering_actor }}"
          echo "::endgroup::"

          BRANCH_PATTERN="${{ inputs.target-branch-pattern }}"
          
          CURRENT_BRANCH="$(git branch --show-current)"
          echo "::notice ::Current Branch: $CURRENT_BRANCH"

          if [[ ! "$CURRENT_BRANCH" =~ ^${BRANCH_PATTERN}$ ]]; then
            echo "::notice ::Not a versioned branch like '**.x'. Skipping."
            echo "branch-skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          git fetch --all

          if [[ -n "${{ inputs.target-branches }}" ]]; then
            IFS=',' read -r -a ALL_BRANCHES <<< "${{ inputs.target-branches }}"
          else
            mapfile -t ALL_BRANCHES < <(git branch -r | grep -oE "origin/${BRANCH_PATTERN}" | sed 's|origin/||' | sort -V)
          fi

          CURRENT_MAJOR=$(echo "$CURRENT_BRANCH" | cut -d'.' -f1)

          FILTERED_BRANCHES=()
          for BRANCH in "${ALL_BRANCHES[@]}"; do
            BRANCH_MAJOR=$(echo "$BRANCH" | cut -d'.' -f1)
            if [[ "$BRANCH" != "$CURRENT_BRANCH" && "$BRANCH_MAJOR" -gt "$CURRENT_MAJOR" ]]; then
              FILTERED_BRANCHES+=("$BRANCH")
            fi
          done

          echo "::notice ::Branches to merge: ${FILTERED_BRANCHES[@]}"

          BRANCHES=$(printf '%s\n' "${FILTERED_BRANCHES[@]}" | jq -R . | jq -cs .)

          if [[ $(echo "$BRANCHES" | jq 'length') -eq 0 ]]; then
            echo "::notice ::No branches to merge. Exiting."
            echo "branch-skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "all-branches=$BRANCHES" >> $GITHUB_OUTPUT
          echo "current-branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
          echo "branch-skip=false" >> $GITHUB_OUTPUT
    
  merge-up:
    name: Merge and Bump for ${{ matrix.branch }}
    runs-on: ubuntu-latest
    needs: get-branches
    if: ${{ needs.get-branches.outputs.branch-skip == 'false' && needs.get-branches.outputs.commit-skip == 'false' }}
    strategy:
      matrix:
        branch: ${{ fromJson(needs.get-branches.outputs.all-branches) }}
    
    steps:
      - name: Checkout full history
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.github-token }}
      
      - name: Merge ${{ needs.get-branches.outputs.current-branch }} into ${{ matrix.branch }}
        id: merge
        run: |
          git fetch --all
          git config user.email "deploy-bot@riverigaming.com"
          git config user.name "rig-autobot"

          CURRENT_BRANCH="${{ needs.get-branches.outputs.current-branch }}"
          TARGET_BRANCH="${{ matrix.branch }}"
          MANUAL_MERGE=false

          echo "::notice ::Attempting to merge $CURRENT_BRANCH â†’ $TARGET_BRANCH"
          
          git checkout $TARGET_BRANCH

          if git merge --no-commit --no-ff --no-edit ${CURRENT_BRANCH}; then
            if [[ (-z "$(git status --porcelain)") ]]; then
              echo "::notice ::Nothing to commit for branch: $TARGET_BRANCH"
            else
              git commit --no-edit
              echo "::notice ::Merged committed for branch $TARGET_BRANCH, processed to version bump"
            fi
            echo "::group::Git Branch & Status --no-edit"
            git branch
            git status
            echo "::endgroup::"
          else
            CONFLICTS=$(git diff --name-only --diff-filter=U)
            VERSION_FILE="${{ inputs.version-file }}"

            for file in $CONFLICTS; do
              if [[ "$file" == "$VERSION_FILE" ]]; then
                echo "::notice ::Auto-resolving $file version conflicts."

                CONFLICT_CONTENT=$(awk '/^<<<<<<< HEAD/,/^>>>>>>>/' "$file" || true)
                echo "::notice::Conflict content: $CONFLICT_CONTENT"

                NON_VERSION_CONFLICT_LINES=$(echo "$CONFLICT_CONTENT" | \
                  grep -vE '<<<<<<<|=======|>>>>>>>' | \
                  grep -vE '^\s*"version"\s*:' || true)

                if [[ -n "$NON_VERSION_CONFLICT_LINES" ]]; then
                  echo "::warning::Failed to auto-resolve $file conflicts. Merge error."
                  git merge --abort
                  echo "manual_merge=true" >> $GITHUB_OUTPUT
                  return 1
                fi

                git checkout --ours $file
                git add $file
                # git commit -m "chore(package): auto-resolve version conflict"
                echo "::notice ::Resolved version conflict in $file"

                echo "::group::Git Branch & Status chore(package)"
                git branch
                git status
                echo "::endgroup::"

              elif [[ "$file" == "package-lock.json" ]]; then
                git checkout --ours $file
                git add package-lock.json
                # git commit -m "chore(package lock): auto-resolve version conflict"
                echo "::notice ::Resolved version conflict in package-lock.json"

              else
                echo "::error ::Conflict in $file - not auto-resolvable"
                git merge --abort
                MANUAL_MERGE=true
                echo "manual_merge=true" >> $GITHUB_OUTPUT
                return 1
              fi
            done

            git commit -m "chore(package): auto-resolve version conflict"
          fi

          echo "::group::Git Branch & Status end one"
          git branch
          git status
          echo "::endgroup::"

          echo "manual-merge=$MANUAL_MERGE" >> $GITHUB_OUTPUT

      - name: Manual Merge Notification
        if: ${{ steps.merge.outputs.manual-merge == 'true' }}
        run: |
          echo "::error ::Conflicts occurred that couldn't be auto-resolved. Please resolve manually."
          exit 1

      - name: Test Git Branch & Status
        run: |
          echo "::group::Git Branch & Status"
          git branch
          git status
          echo "::endgroup::"
      
      - name: Bump Patch Version
        id: bump
        if: ${{ steps.merge.outputs.manual-merge == 'false' }}
        uses: River-iGaming/actions/auto-bump@feature/auto-bump-update-merge-higher-skip-checkout
        with:
          branch: ${{ matrix.branch }}
          semver: patch
          include-commit: 'false'
          do-checkout: 'false'
          github-token: ${{ secrets.github-token }}
      
      - name: Commit and Push
        id: commit-push
        if: ${{ steps.merge.outputs.manual-merge == 'false' }}
        run: |
          NEW_VERSION=$(echo '${{ steps.bump.outputs.all }}' | jq -r '.new_version')
          
          echo "::notice ::Bumped version : $NEW_VERSION"

          echo "::group::Git Branch & Status"
          git branch
          git status
          echo "::endgroup::"

          # git add package.json
          git add -A
          git commit -m "chore(*): changes merged and with version bump to $NEW_VERSION"
          git push origin ${{ matrix.branch }}

          echo "::notice ::Pushing changes to ${{ matrix.branch }} with version bump to $NEW_VERSION"