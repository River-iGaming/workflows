name: Merge to Higher Branches
on:
  workflow_call:
    inputs:
      version-file:
        description: File containing the app version
        required: false
        type: string
        default: "package.json"
      target-branch-pattern:
        description: Regex pattern for target branches
        required: false
        type: string
        default: "[0-9]+\\.x"
      target-branches:
        description: Explicit list of target branches
        required: false
        type: string
    secrets:
      github-token:
        required: true
jobs:
  get-branches:
    name: Merge to Higher Branches
    runs-on: ubuntu-latest
    outputs:
      all-branches: ${{ steps.branch-info.outputs.all-branches }}
      current-branch: ${{ steps.branch-info.outputs.current-branch }}
    steps:
      - name: Checkout full history
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Get current branch
        id: branch-info
        run: |
          git config user.email "deploy-bot@riverigaming.com"
          git config user.name "rig-autobot"

          BRANCH_PATTERN="${{ inputs.target-branch-pattern }}"
          
          CURRENT_BRANCH="$(git branch --show-current)"

          if [[ ! "$CURRENT_BRANCH" =~ ^${BRANCH_PATTERN}$ ]]; then
            echo "::notice ::Not a versioned branch like '**.x'. Skipping."
            exit 0
          fi

          git fetch --all
          # todo need to remove current branch exists in the all branches
          if [[ -n "${{ inputs.target-branches }}" ]]; then
            IFS=',' read -r -a TARGET_BRANCH_ARRAY <<< "${{ inputs.target-branches }}"
            ALL_BRANCHES="${TARGET_BRANCH_ARRAY[@]}"
          else
            ALL_BRANCHES=$(git branch -r | grep -oE "origin/${BRANCH_PATTERN}" | sed 's|origin/||' | sort -V)
          fi

          echo "::notice ::Branches to merge: $ALL_BRANCHES"

          echo "all-branches=$ALL_BRANCHES" >> $GITHUB_OUTPUT
          echo "current-branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
    
  merge-up:
    name: Merge and Bump for ${{ matrix.branch }}
    runs-on: ubuntu-latest
    needs: get-branches
    strategy:
      matrix:
        branch: ${{ needs.get-branches.outputs.all-branches }}
      
    steps:
      - name: Checkout full history
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.github-token }}
      
      - name: Merge ${{ needs.get-branches.outputs.current-branch }} into ${{ matrix.branch }}
        id: merge
        run: |
          CURRENT_BRANCH="${{ needs.get-branches.outputs.current-branch }}"
          TARGET_BRANCH="${{ matrix.branch }}"
          MANUAL_MERGE=false

          echo "::notice ::Attempting to merge $CURRENT_BRANCH â†’ $TARGET_BRANCH"
          
          git fetch origin $CURRENT_BRANCH
          git fetch origin $TARGET_BRANCH
          git checkout $TARGET_BRANCH

          if git merge --no-commit --no-ff --no-edit ${CURRENT_BRANCH}; then
            if [[ (-z "$(git status --porcelain)") ]]; then
              echo "::notice ::Nothing to commit for branch: $TARGET_BRANCH"
            else
              git commit --no-edit
              # git push origin $branch
            fi
          else
            CONFLICTS=$(git diff --name-only --diff-filter=U)
            VERSION_FILE="${{ inputs.version-file }}"

            for file in $CONFLICTS; do
              if [[ "$file" == "$VERSION_FILE" ]]; then
                echo "::notice ::Auto-resolving $file version conflicts."

                conflict_content=$(awk '/^<<<<<<< HEAD/,/^>>>>>>>/' "$file" || true)
                echo "::notice ::Conflict content: $conflict_content"
                
                non_version_conflict_lines=$(echo "$conflict_content" | \
                  grep -vE '<<<<<<<|=======|>>>>>>>' | \
                  grep -vE '^\s*"version"\s*:' || true)

                if [[ -n "$non_version_conflict_lines" ]]; then
                  echo "::error ::Unresolvable conflicts in $file"
                  git merge --abort
                  echo "manual_merge=true" >> $GITHUB_OUTPUT
                  exit 1
                fi

                git checkout --theirs $file
                git add $file
                git commit -m "chore(package): auto-resolve version conflict"
                echo "::notice ::Resolved version conflict in $file"
              else
                echo "::error ::Conflict in $file - not auto-resolvable"
                git merge --abort
                MANUAL_MERGE=true
                echo "manual_merge=true" >> $GITHUB_OUTPUT
                exit 1
              fi
            done
            if [ "$MANUAL_MERGE" = false ]; then
              git commit -m "chore(*): auto-resolve version conflicts"
            fi
          fi

          # git push origin $TARGET_BRANCH
          echo "manual-merge=$MANUAL_MERGE" >> $GITHUB_OUTPUT

      - name: Manual Merge Notification
        if: ${{ steps.merge.outputs.manual-merge == 'true' }}
        run: |
          echo "::error ::Conflicts occurred that couldn't be auto-resolved. Please resolve manually."
          exit 1
      
      - name: Bump Patch Version
        id: bump
        if: ${{ steps.merge.outputs.manual-merge == 'false' }}
        uses: River-iGaming/actions/auto-bump@feature/auto-bump-update-merge-higher
        with:
          branch: ${{ matrix.branch }}
          semver: patch
          commit: 'false'
          github-token: ${{ secrets.github-token }}
      
      - name: Commit and Push
        id: commit-push
        run: |
          NEW_VERSION=$(echo '${{ steps.bump.outputs.all }}' | jq -r '.new_version')
          
          echo "::notice ::Bumped version : $NEW_VERSION"

          echo "::group::Git Branch & Status"
          git branch
          git status
          echo "::endgroup::"

          git checkout ${{ matrix.branch }}
          git add package.json
          git commit -m "chore(package): auto bump version to $NEW_VERSION"
          git push origin ${{ matrix.branch }}
    
