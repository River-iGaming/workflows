name: Downmerge releases

on:
  workflow_call:
    inputs:
        base-branch:
          description: Base branch of the repo to downmerge to
          required: false
          type: string
          default: "master"
        version-file:
          description: File containing the app version
          required: false
          type: string
          default: "package.json"
    secrets:
      github-token:
        required: true

jobs:
  checks:
    name: Downmerge to a base and release branches
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.github-token }}

      - name: Downmerge
        id: downmerge
        run: |
          git fetch
          git config user.email "deploy-bot@riverigaming.com"
          git config user.name "rig-autobot"

          MANUAL_MERGE=false
          # Determine the current branch and package version
          BASE_BRANCH="${{ inputs.base-branch }}"
          CURRENT_BRANCH="$(git branch --show-current)"
          PACKAGE_VERSION=$(node -p "require('./package.json').version")

          if [[ "$PACKAGE_VERSION" == *"-"* || "$PACKAGE_VERSION" == *"+"* ]]; then 
            echo "::error ::Downmerge is not allowed for prerelease versions or versions with metadata."
            exit 1
          fi

          if [[ "$CURRENT_BRANCH" =~ "release" ]]; then
            BASE_PACKAGE_VERSION=$(echo $CURRENT_BRANCH | cut -d'/' -f2)
          else
            BASE_PACKAGE_VERSION=$PACKAGE_VERSION
          fi

          # Iterate through branches and downmerge if they match the pattern
          for branch in $(git for-each-ref --format='%(refname:short)' 'refs/remotes/origin/release-test/*' "refs/remotes/origin/${{ inputs.base-branch }}"); do
            echo "::group::Branch: $branch"
            branch="${branch#origin/}" # Remove the 'origin/' prefix
            if [ "$branch" == "$CURRENT_BRANCH" ]; then
              echo "::notice ::Skipping current branch: $branch"
              echo "::endgroup::"
              continue
            fi

            BRANCH_VERSION=$(echo $branch | cut -d'/' -f2)
            NEWER_VERSION="$(printf '%s\n' "$BRANCH_VERSION" "$BASE_PACKAGE_VERSION" | sort -V | tail -n 1)"
            # IS_CURRENT_RELEASE_BRANCH=$(if [[ $BRANCH_VERSION == $BASE_PACKAGE_VERSION ]]; then echo "true"; else echo "false"; fi)

            echo "::notice ::Current branch: $CURRENT_BRANCH"
            echo "::notice ::Branch version: $BRANCH_VERSION"
            echo "::notice ::Base package version: $BASE_PACKAGE_VERSION"
            echo "::notice ::Newer version: $NEWER_VERSION"

            if [[ $branch == $BASE_BRANCH || $NEWER_VERSION == $BRANCH_VERSION ]]; then
              echo "::notice ::Downmerging branch: $branch from: $CURRENT_BRANCH"

              git checkout $branch

              # Merge changes from the remote branch into branch
              if git merge --no-commit --no-ff --no-edit ${CURRENT_BRANCH}; then
                if [[ (-z "$(git status --porcelain)") ]]; then
                  echo "::notice ::Nothing to commit for branch: $branch"
                else
                  git commit --no-edit
                  git push origin $branch
                fi
              else
                CONFLICTS="$(git diff --name-only --diff-filter=U)"
                VERSION_FILE="${{ inputs.version-file }}"

                echo "::notice ::Conflicts: $CONFLICTS"
                for file in $CONFLICTS; do
                  if [ "$file" == "$VERSION_FILE" ]; then
                    echo "::notice ::Auto-resolving $file version conflicts."

                    conflict_content=$(awk '/^<<<<<<< HEAD/,/^>>>>>>>/' "$file" || true)
                    echo "::notice ::Conflict content: $conflict_content"

                    non_version_conflict_lines=$(echo "$conflict_content" | \
                      grep -vE '<<<<<<<|=======|>>>>>>>' | \
                      grep -vE '^\s*"version"\s*:' || true)
                    echo "::notice ::non_version_conflict_lines: $non_version_conflict_lines"  

                    if [[ -n "$non_version_conflict_lines" ]]; then
                      echo "::warning ::Failed to auto-resolve $file conflicts. Merge error."
                      echo "::endgroup::"
                      continue 2 # Skip to the next branch
                    fi

                    git checkout --ours $file
                    git add $file

                    if [[ (-z "$(git status --porcelain)") ]]; then
                      echo "::notice ::Nothing to commit for branch: $branch."
                    else  
                      echo "::notice ::Auto-resolve $VERSION_FILE version conflicts by choosing the HEAD version."
                      MANUAL_MERGE=true
                    fi
                  else
                    echo "::warning ::Failed to downmerge to branch: $branch. Merge error."
                    echo "::endgroup::"
                    continue 2 # Skip to the next branch
                  fi
                done
                if [ "$MANUAL_MERGE" = true ]; then
                  git commit -m "chore(*): auto-resolve version conflicts"
                  git push origin $branch
                fi
              fi
            fi
            echo "manual-merge=${MANUAL_MERGE}" >> "$GITHUB_OUTPUT"
            echo "::endgroup::"
          done
      - name: Manual Merge Notification
        if: ${{ steps.downmerge.outputs.manual-merge == 'true' }}
        run: |
            echo "::error ::Auto merged conflicts. Review Changes Manually."
            exit 1
            
